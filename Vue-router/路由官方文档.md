### 动态路由匹配 

使用某种模式匹配到所有路由。映射到同个组件 可以在路由路径中使用 动态路径参数 达到这个效果

```javascript
const router = new VueRouter({
    routes: [
      // 动态路径参数 以冒号开头
      { path: '/user/:id', component: User },
    ]
})
```

像 /user/foo  /user/bar 都将映射到相同的路由。 : 匹配一个路由时 参数值会被设置到 this.$route.params 

还可以配置多短 路径参数 都会设置到  /user/:username/post/:post_id

```javascript
// this.$route.params 返回路径参数
{ id: foo } { id: bar }

// 还可以配置多段 路径参数 都会设置到  /user/:username/post/:post_id
/user/evan/post/123 {username: 'evan', post_id: 123}
```



#### 路由参数的变化

当使用路由参数时 从/user/foo 到 /user/bar **原来的组件实例会被复用 因为两个路由都渲染同个组件 但是组件的生命周期钩子不会再被调用** 如果想要对路由参数的变化作出响应的话 简单地watch 监测变化 $route 对象

```javascript
const user = {
    watch: {
        '$route' (to, from) {
            // 对路由变化作出响应
        }
    }
}
```



### 路由嵌套

**使用 / 开头 的嵌套路由被当做根路径 这让你充分的使用嵌套组件而无须设置嵌套的路径**

```javascript
const router= new VueRouter({
    routes: [
        {
            path: '/user/:id',
            component: User,
            children: [
                // 当/user/:id匹配成功
                // UserHome 会被渲染在User的 <router-view>
                {
                    path: '',
                    component: () => import('@/components/UserHome')
                }
            ]
        }
    ] 
});
```



### 编程式导航

router.push(location, onComplete, onAbort)

声明式 		<router-link :to="...">		

 编程式 	         router.push(...)

```javascript
// 字符串
router.push('home')

// 对象
router.push({path: 'home'});

// 命名的路由
router.push({name: 'user', params: {userId: 123}}) // -> /user/123

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})

router.push({ path: `/user/${userId}` }) // -> /user/123
// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -> /user

```



### 导航守卫

vue-router 提供的导航守卫主要来通过跳转或取消的方式守卫导航。守卫是异步解析执行 此时导航在所有守卫resolve完之前一直处于等待中

```javascript
// 验证用户是否有token,没有token跳转到登录页面
router.beforeEach((to, from, next) => {
  const ignoreList = ['/login', '/signin', '/forgot', '/test_auth'];
  const token = cookie.get('token');
  const ignore = !!(ignoreList.find(v => v === to.path));
  if (ignore) {
    next();
  } else if (!token) {
    next({ path: '/login' });
  } else {
    next();
  }
});
```

to 即将要进入的目标 路由对象

from 当前导航正要离开的路由

next 一定要调用该方法 resolve这个钩子



### 全局后置守卫

后置守卫 守卫不同的是 没有next函数 也不会改变导航本身

l路由独享的守卫

```javascript
router.afterEach((to, from) => {
    // ...
});

// 路由独享的守卫 就是在每个路由里面写
const router = new VueRouter({
    routes: [{
        path: '/foo',
        component: Foo,
        beforeEach: (to, from, next) => {

        }
    }]
});
```



### 路由元信息













